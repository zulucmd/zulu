package doc_test

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/zulucmd/zflag/v2"
	"github.com/zulucmd/zulu/v2"
	"github.com/zulucmd/zulu/v2/doc"
	"github.com/zulucmd/zulu/v2/internal/testutil"
)

func translate(in string) string {
	return strings.ReplaceAll(in, "-", "\\-")
}

func TestGenManDoc(t *testing.T) {
	rootCmd, echoCmd, echoSubCmd, _, deprecatedCmd, _, _ := getTestCmds()
	header := &doc.GenManHeader{
		Title:   "Project",
		Section: "2",
	}

	// We generate on a subcommand so we have both subcommands and parents
	buf := new(bytes.Buffer)
	if err := doc.GenMan(echoCmd, header, buf); err != nil {
		t.Fatal(err)
	}
	output := buf.String()

	// Make sure parent has - in CommandPath() in SEE ALSO:
	parentPath := echoCmd.Parent().CommandPath()
	dashParentPath := strings.ReplaceAll(parentPath, " ", "-")
	expected := translate(dashParentPath)
	expected = expected + "(" + header.Section + ")"
	testutil.AssertContains(t, output, expected)

	testutil.AssertContains(t, output, translate(echoCmd.Name()))
	testutil.AssertContains(t, output, translate(echoCmd.Name()))
	testutil.AssertContains(t, output, "boolone")
	testutil.AssertContains(t, output, "rootflag")
	testutil.AssertContains(t, output, translate(rootCmd.Name()))
	testutil.AssertContains(t, output, translate(echoSubCmd.Name()))
	testutil.AssertNotContains(t, output, translate(deprecatedCmd.Name()))
	testutil.AssertContains(t, output, translate("Auto generated"))
}

func TestGenManNoHiddenParents(t *testing.T) {
	rootCmd, echoCmd, echoSubCmd, _, deprecatedCmd, _, _ := getTestCmds()
	header := &doc.GenManHeader{
		Title:   "Project",
		Section: "2",
	}

	// We generate on a subcommand so we have both subcommands and parents
	for _, name := range []string{"rootflag", "strtwo"} {
		f := rootCmd.PersistentFlags().Lookup(name)
		f.Hidden = true
	}
	buf := new(bytes.Buffer)
	if err := doc.GenMan(echoCmd, header, buf); err != nil {
		t.Fatal(err)
	}
	output := buf.String()

	// Make sure parent has - in CommandPath() in SEE ALSO:
	parentPath := echoCmd.Parent().CommandPath()
	dashParentPath := strings.ReplaceAll(parentPath, " ", "-")
	expected := translate(dashParentPath)
	expected = expected + "(" + header.Section + ")"
	testutil.AssertContains(t, output, expected)

	testutil.AssertContains(t, output, translate(echoCmd.Name()))
	testutil.AssertContains(t, output, translate(echoCmd.Name()))
	testutil.AssertContains(t, output, "boolone")
	testutil.AssertNotContains(t, output, "rootflag")
	testutil.AssertContains(t, output, translate(rootCmd.Name()))
	testutil.AssertContains(t, output, translate(echoSubCmd.Name()))
	testutil.AssertNotContains(t, output, translate(deprecatedCmd.Name()))
	testutil.AssertContains(t, output, translate("Auto generated"))
	testutil.AssertNotContains(t, output, "OPTIONS INHERITED FROM PARENT COMMANDS")
}

func TestGenManNoGenTag(t *testing.T) {
	_, echoCmd, _, _, _, _, _ := getTestCmds()
	echoCmd.DisableAutoGenTag = true

	header := &doc.GenManHeader{
		Title:   "Project",
		Section: "2",
	}

	// We generate on a subcommand so we have both subcommands and parents
	buf := new(bytes.Buffer)
	if err := doc.GenMan(echoCmd, header, buf); err != nil {
		t.Fatal(err)
	}
	output := buf.String()

	unexpected := translate("#HISTORY")
	testutil.AssertNotContains(t, output, unexpected)
	unexpected = translate("Auto generated by zulucmd/zulu")
	testutil.AssertNotContains(t, output, unexpected)
}

func TestGenManNoGenTagWithDisabledParent(t *testing.T) {
	rootCmd, echoCmd, _, _, _, _, _ := getTestCmds()
	// We set the flag on a parent to check it is used in its descendance
	rootCmd.DisableAutoGenTag = true

	header := &doc.GenManHeader{
		Title:   "Project",
		Section: "2",
	}

	// We generate on a subcommand so we have both subcommands and parents
	buf := new(bytes.Buffer)
	if err := doc.GenMan(echoCmd, header, buf); err != nil {
		t.Fatal(err)
	}
	output := buf.String()

	unexpected := translate("#HISTORY")
	testutil.AssertNotContains(t, output, unexpected)
	unexpected = translate("Auto generated by zulucmd/zulu")
	testutil.AssertNotContains(t, output, unexpected)
}

func TestGenManSeeAlso(t *testing.T) {
	rootCmd := &zulu.Command{
		Use:   "git",
		Short: "the stupid content tracker",
		Long: "Git is a fast, scalable, distributed revision control system with an unusually rich command " +
			"set that provides both high-level operations and full access to internals.",
		RunE: emptyRun,
	}
	aCmd := &zulu.Command{Use: "clone", RunE: emptyRun, Hidden: true} // #229
	bCmd := &zulu.Command{Use: "checkout", RunE: emptyRun}
	cCmd := &zulu.Command{Use: "branch", RunE: emptyRun}
	rootCmd.AddCommand(aCmd, bCmd, cCmd)

	// todo add the flags in the SYNOPSIS section. Instead of just writing "git [flags]",
	//  it should write "git [-C <path>]"
	rootCmd.Flags().String(
		"chdir",
		"",
		"Run as if git was started in <path> instead of the current working directory.",
		zflag.OptShorthand('C'),
		zflag.OptShorthandOnly(),
		zflag.OptUsageType("<path>"),
	)

	buf := new(bytes.Buffer)
	header := &doc.GenManHeader{}
	if err := doc.GenMan(rootCmd, header, buf); err != nil {
		t.Fatal(err)
	}
	scanner := bufio.NewScanner(buf)

	if err := assertLineFound(scanner, ".SH SEE ALSO"); err != nil {
		t.Fatalf("Couldn't find SEE ALSO section header: %v", err)
	}
	if err := assertNextLineEquals(
		scanner,
		`\fBgit-branch(1)\fP, \fBgit-checkout(1)\fP, \fBgit-completion(1)\fP`,
	); err != nil {
		t.Fatalf("Second line after SEE ALSO wasn't correct: %v", err)
	}
}

func TestManPrintFlagsHidesShortDeprecated(t *testing.T) {
	c := &zulu.Command{}
	c.Flags().String(
		"foo",
		"default",
		"Foo flag",
		zflag.OptShorthand('f'),
		zflag.OptShorthandDeprecated("don't use it no more"),
	)

	buf := new(bytes.Buffer)
	doc.ManPrintFlags(buf, c.Flags())

	got := buf.String()
	expected := "**--foo** string\n\n\tFoo flag\n\tDefaults to: default\n\n"
	if got != expected {
		t.Errorf("Expected %v, got %v", expected, got)
	}
}

func TestGenManCommands(t *testing.T) {
	rootCmd, echoCmd, _, timesCmd, _, _, _ := getTestCmds()
	header := &doc.GenManHeader{
		Title:   "Project",
		Section: "2",
	}

	// Root command
	buf := new(bytes.Buffer)
	if err := doc.GenMan(rootCmd, header, buf); err != nil {
		t.Fatal(err)
	}
	output := buf.String()

	testutil.AssertContains(t, output, ".SH COMMANDS")
	testutil.AssertMatch(t, output, `\\fBecho\\fP

\.EX
Echo anything to the screen
See \*\*root\-echo\(2\)\*\*\.
\.EE`)
	testutil.AssertNotContains(t, output, ".PP\n\\fBprint\\fP\n")

	// Echo command
	buf = new(bytes.Buffer)
	if err := doc.GenMan(echoCmd, header, buf); err != nil {
		t.Fatal(err)
	}
	output = buf.String()

	testutil.AssertContains(t, output, ".SH COMMANDS")
	testutil.AssertMatch(t, output, `\\fBtimes\\fP

\.EX
Echo anything to the screen more times
See \*\*root\-echo\-times\(2\)\*\*\.
\.EE`)
	testutil.AssertMatch(t, output, `\\fBechosub\\fP

\.EX
second sub command for echo
See \*\*root\-echo\-echosub\(2\)\*\*\.
\.EE`)
	testutil.AssertNotContains(t, output, ".PP\n\\fBdeprecated\\fP\n")

	// Time command as echo's subcommand
	buf = new(bytes.Buffer)
	if err := doc.GenMan(timesCmd, header, buf); err != nil {
		t.Fatal(err)
	}
	output = buf.String()

	testutil.AssertNotContains(t, output, ".SH COMMANDS")
}

func TestGenManTree(t *testing.T) {
	c := &zulu.Command{Use: "do [OPTIONS] arg1 arg2"}
	header := &doc.GenManHeader{Section: "2"}
	tmpdir := t.TempDir()

	if err := doc.GenManTree(c, header, tmpdir); err != nil {
		t.Fatalf("GenManTree failed: %s", err.Error())
	}

	if _, err := os.Stat(filepath.Join(tmpdir, "do.2")); err != nil {
		t.Fatalf("Expected file 'do.2' to exist")
	}

	if header.Title != "" {
		t.Fatalf("Expected header.Title to be unmodified")
	}
}

func assertLineFound(scanner *bufio.Scanner, expectedLine string) error {
	for scanner.Scan() {
		line := scanner.Text()
		if line == expectedLine {
			return nil
		}
	}

	if err := scanner.Err(); err != nil {
		return fmt.Errorf("scan failed: %w", err)
	}

	return fmt.Errorf("hit EOF before finding %v", expectedLine)
}

func assertNextLineEquals(scanner *bufio.Scanner, expectedLine string) error {
	if scanner.Scan() {
		line := scanner.Text()
		if line == expectedLine {
			return nil
		}
		return fmt.Errorf("got %v, not %v", line, expectedLine)
	}

	if err := scanner.Err(); err != nil {
		return fmt.Errorf("scan failed: %w", err)
	}

	return fmt.Errorf("hit EOF before finding %v", expectedLine)
}

func BenchmarkGenManToFile(b *testing.B) {
	rootCmd, _, _, _, _, _, _ := getTestCmds()
	file, err := os.CreateTemp(b.TempDir(), "")
	if err != nil {
		b.Fatal(err)
	}
	defer os.Remove(file.Name())
	defer file.Close()

	b.ResetTimer()
	for range b.N {
		if err := doc.GenMan(rootCmd, nil, file); err != nil {
			b.Fatal(err)
		}
	}
}
