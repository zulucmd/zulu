//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package doc

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	tmpl "text/template"
	"time"

	"github.com/zulucmd/zulu/v2"
)

func defaultManDocLinkHandler(f string, s string) string {
	f = strings.ReplaceAll(f, " ", "_")
	return fmt.Sprintf("%s.%s", f, s)
}

// GenManTreeOptions is the options for generating the man pages.
// Used only in GenManTreeFromOpts.
type GenManTreeOptions struct {
	Header           *GenManHeader
	Path             string
	CommandSeparator string
}

// GenManHeader is a lot like the .TH header at the start of man pages. These
// include the title, section, date, source, and manual. We will use the
// current time if Date is unset and will use "Auto generated by zulucmd/zulu"
// if the Source is unset.
type GenManHeader struct {
	Title   string
	Section string
	Date    time.Time
	Source  string
	Manual  string
}

// GenMan will generate a man page for the given command and write it to
// w. The header argument may be nil, however obviously w may not.
func GenMan(cmd *zulu.Command, header *GenManHeader, w io.Writer, linkHandler linkHandlerFn) error {
	if header == nil {
		header = &GenManHeader{}
	}

	if linkHandler == nil {
		linkHandler = defaultManDocLinkHandler
	}

	if cmd.HasParent() {
		cmd.VisitParents(func(c *zulu.Command) {
			if c.DisableAutoGenTag {
				cmd.DisableAutoGenTag = c.DisableAutoGenTag
			}
		})
	}
	if err := fillHeader(header, cmd.CommandPath(), cmd.DisableAutoGenTag); err != nil {
		return err
	}

	return generateFromTemplate(
		"templates/docs.man.gotmpl",
		cmd,
		w,
		map[string]any{"Header": header},
		tmpl.FuncMap{"to_link": linkHandler},
	)
}

// GenManTree will generate a man page for this command and all descendants
// in the directory given. The header may be nil. This function may not work
// correctly if your command names have `-` in them. If you have `cmd` with two
// subcmds, `sub` and `sub-third`, and `sub` has a subcommand called `third`
// it is undefined which help output will be in the file `cmd-sub-third.1`.
func GenManTree(cmd *zulu.Command, header *GenManHeader, dir string, linkHandler linkHandlerFn) error {
	if header == nil {
		header = &GenManHeader{}
	}
	if linkHandler == nil {
		linkHandler = defaultManDocLinkHandler
	}

	for _, c := range cmd.Commands() {
		if !c.IsAvailableCommand() || c.IsAdditionalHelpTopicCommand() {
			continue
		}
		if err := GenManTree(c, header, dir, linkHandler); err != nil {
			return err
		}
	}
	section := "1"
	if header.Section != "" {
		section = header.Section
	}

	basename := linkHandler(cmd.CommandPath(), section)
	filename := filepath.Join(dir, basename)
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	headerCopy := *header
	return GenMan(cmd, &headerCopy, f, linkHandler)
}

func fillHeader(header *GenManHeader, name string, disableAutoGen bool) error {
	if header.Title == "" {
		header.Title = strings.ToUpper(strings.ReplaceAll(name, " ", "\\-"))
	}
	if header.Section == "" {
		header.Section = "1"
	}
	if header.Date.IsZero() {
		if epoch := os.Getenv("SOURCE_DATE_EPOCH"); epoch != "" {
			unixEpoch, err := strconv.ParseInt(epoch, 10, 64)
			if err != nil {
				return fmt.Errorf("invalid SOURCE_DATE_EPOCH: %w", err)
			}
			header.Date = time.Unix(unixEpoch, 0)
		} else {
			header.Date = time.Now()
		}
	}
	if header.Source == "" && !disableAutoGen {
		header.Source = "Auto generated by zulucmd/zulu"
	}
	return nil
}
