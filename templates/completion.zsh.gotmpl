#compdef -a {{ .CMDVarName }}

# -*- shell-script -*-
# zsh completion for {{ .CMDName }}

__{{ .CMDVarName }}_debug() {
  local file="$BASH_COMP_DEBUG_FILE"
  if [[ -n ${file} ]]; then
    echo "$*" >>"${file}"
  fi
}

_{{ .CMDVarName }}() {
  local shellCompDirectiveError={{ .ShellCompDirectiveError }}
  local shellCompDirectiveNoSpace={{ .ShellCompDirectiveNoSpace }}
  local shellCompDirectiveNoFileComp={{ .ShellCompDirectiveNoFileComp }}
  local shellCompDirectiveFilterFileExt={{ .ShellCompDirectiveFilterFileExt }}
  local shellCompDirectiveFilterDirs={{ .ShellCompDirectiveFilterDirs }}
  local shellCompDirectiveKeepOrder={{ .ShellCompDirectiveKeepOrder }}

  local lastParam lastChar flagPrefix requestComp out directive comp lastComp noSpace keepOrder
  local -a completions

  __{{ .CMDVarName }}_debug "\n========= starting completion logic =========="
  __{{ .CMDVarName }}_debug "CURRENT: ${CURRENT}, words[*]: ${words[*]}"

  # The user could have moved the cursor backwards on the command-line.
  # We need to trigger completion from the $CURRENT location, so we need
  # to truncate the command-line ($words) up to the $CURRENT location.
  # (We cannot use $CURSOR as its value does not work when a command is an alias.)
  words=("${=words[1,CURRENT]}")
  __{{ .CMDVarName }}_debug "Truncated words[*]: ${words[*]},"

  lastParam=${words[-1]}
  lastChar=${lastParam[-1]}
  __{{ .CMDVarName }}_debug "lastParam: ${lastParam}, lastChar: ${lastChar}"

  # For zsh, when completing a flag with an = (e.g., {{ .CMDVarName }} -n=<TAB>)
  # completions must be prefixed with the flag
  setopt local_options BASH_REMATCH
  if [[ "${lastParam}" =~ -.*= ]]; then
    # We are dealing with a flag with an =
    flagPrefix="-P ${BASH_REMATCH}"
  fi

  # Prepare the command to obtain completions
  requestComp="${words[1]} {{ .CompletionCommand }} ${words[2,-1]}"
  if [[ $lastChar == "" ]]; then
    # If the last parameter is complete (there is a space following it)
    # We add an extra empty parameter, so we can indicate this to the go completion code.
    __{{ .CMDVarName }}_debug "Adding extra empty parameter"
    requestComp="${requestComp} \"\""
  fi

  __{{ .CMDVarName }}_debug "About to call: eval ${requestComp}"

  # Use eval to handle any environment variables and such
  out=$(eval ${requestComp} 2>/dev/null)
  __{{ .CMDVarName }}_debug "completion output: ${out}"

  # Extract the directive integer following a : from the last line
  local lastLine
  while IFS=$'\n' read -r line; do
    lastLine=${line}
  done < <(printf "%s\n" "${out[@]}")
  __{{ .CMDVarName }}_debug "last line: ${lastLine}"

  if [[ "${lastLine[1]}" == : ]]; then
    directive=${lastLine[2,-1]}
    # Remove the directive including the : and the newline
    local suffix
    ((suffix = ${#lastLine} + 2))
    out=${out[1,-$suffix]}
  else
    # There is no directive specified.  Leave $out as is.
    __{{ .CMDVarName }}_debug "No directive found.  Setting do default"
    directive=0
  fi

  __{{ .CMDVarName }}_debug "directive: ${directive}"
  __{{ .CMDVarName }}_debug "completions: ${out}"
  __{{ .CMDVarName }}_debug "flagPrefix: ${flagPrefix}"

  if (((directive & shellCompDirectiveError) != 0)); then
    __{{ .CMDVarName }}_debug "Completion received error. Ignoring completions."
    return
  fi

  while IFS=$'\n' read -r comp; do
    if [[ -n $comp ]]; then
      # If requested, completions are returned with a description.
      # The description is preceded by a TAB character.
      # For zsh's _describe, we need to use a : instead of a TAB.
      # We first need to escape any : as part of the completion itself.
      comp=${comp//:/\\:}

      local tab=$'\t'
      comp=${comp//$tab/:}

      __{{ .CMDVarName }}_debug "Adding completion: ${comp}"
      completions+=${comp}
      lastComp=$comp
    fi
  done < <(printf "%s\n" "${out[@]}")

  if (((directive & shellCompDirectiveNoSpace) != 0)); then
    __{{ .CMDVarName }}_debug "Activating nospace."
    noSpace="-S ''"
  fi

  if (((directive & shellCompDirectiveKeepOrder) != 0)); then
    __{{ .CMDVarName }}_debug "Activating keep order."
    keepOrder="-V"
  fi

  if (((directive & shellCompDirectiveFilterFileExt) != 0)); then
    # File extension filtering
    local filteringCmd
    filteringCmd='_files'
    for filter in "${completions[@]}"; do
      if [[ ${filter[1]} != '*' ]]; then
        # zsh requires a glob pattern to do file filtering
        filter="\*.$filter"
      fi
      filteringCmd+=" -g $filter"
    done
    filteringCmd+=" ${flagPrefix}"

    __{{ .CMDVarName }}_debug "File filtering command: $filteringCmd"
    _arguments '*:filename:'"$filteringCmd"
  elif (((directive & shellCompDirectiveFilterDirs) != 0)); then
    # File completion for directories only
    local subdir
    subdir="${completions[1]}"
    if [[ -n "$subdir" ]]; then
      __{{ .CMDVarName }}_debug "Listing directories in $subdir"
      pushd "${subdir}" >/dev/null 2>&1
    else
      __{{ .CMDVarName }}_debug "Listing directories in ."
    fi

    local result
    _arguments '*:dirname:_files -/'" ${flagPrefix}"
    result=$?
    if [[ -n "$subdir" ]]; then
      popd >/dev/null 2>&1
    fi
    return $result
  else
    __{{ .CMDVarName }}_debug "Calling _describe"
    if eval _describe $keepOrder "completions" completions $flagPrefix $noSpace; then
      __{{ .CMDVarName }}_debug "_describe found some completions"

      # Return the success of having called _describe
      return 0
    else
      __{{ .CMDVarName }}_debug "_describe did not find completions."
      __{{ .CMDVarName }}_debug "Checking if we should do file completion."
      if (((directive & shellCompDirectiveNoFileComp) != 0)); then
        __{{ .CMDVarName }}_debug "deactivating file completion"

        # We must return an error code here to let zsh know that there were no
        # completions found by _describe; this is what will trigger other
        # matching algorithms to attempt to find completions.
        # For example zsh can match letters in the middle of words.
        return 1
      else
        # Perform file completion
        __{{ .CMDVarName }}_debug "Activating file completion"

        # We must return the result of this command, so it must be the
        # last command, or else we must store its result to return it.
        _arguments '*:filename:_files'" ${flagPrefix}"
      fi
    fi
  fi
}

# don't run the completion function when being source-ed or eval-ed
if [[ "${funcstack[1]}" == "_{{ .CMDVarName }}" ]]; then
  _{{ .CMDVarName }}
fi
